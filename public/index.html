<html>
  <head>
    <title>Design x Metatooth</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="shortcut icon" href="favicon.ico" />
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <body>
    <div id="container"></div>
    <div id="logo"><img width="200" src="images/metatooth.png" alth="Metatooth Logo"></div>
    <script type="module">
      import * as THREE from '../build/three.module.js';

      import { OrbitControls } from './jsm/controls/OrbitControls.js';
      import { STLLoader } from './jsm/loaders/STLLoader.js';
      import { WEBGL } from './jsm/WebGL.js';

      let container;

      let camera, controls, scene, raycaster, renderer;
      let ambient, key_light, fill_light, back_light, top_light;

      const frustumSize = 1000;
      let aspect = window.innerWidth / window.innerHeight;  

      let INTERSECTED;
      let SHIFT_IS_DOWN;
      let ASSET;
      
      const MOUSE = new THREE.Vector2();

      const PICKED_POINTS = new THREE.Group();
      
      if ( WEBGL.isWebGLAvailable() ) {
	  
	  init();
	  animate();
	  
      } else {
	  
	  const warning = WEBGL.getWebGLErrorMessage();
	  document.getElementById( 'container' ).appendChild( warning );
	  
      }
      
      function init() {

	  container = document.getElementById('container');

	  // Camera
	  
	  camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 1, 1000);
	  camera.lookAt(0, 0, 0);
	  camera.zoom = 10;
	  camera.position.set(0, 0, 10);
	  camera.updateProjectionMatrix();

	  // Scene
	  
	  scene = new THREE.Scene();
	  scene.add(PICKED_POINTS);

	  // Lights

	  ambient = new THREE.AmbientLight( 0xffffff, 0.25 );
	  scene.add(ambient);
	  
	  key_light = new THREE.DirectionalLight( 0x00bbee, 1.0 );
	  key_light.position.set(-100, 0, 100);
	  const key_light_helper = new THREE.DirectionalLightHelper( key_light );
	  
	  fill_light = new THREE.DirectionalLight( 0xff33bb, 0.75 );
	  fill_light.position.set(100, 0, 100);
	  const fill_light_helper = new THREE.DirectionalLightHelper( fill_light );

	  back_light = new THREE.DirectionalLight( 0xffffff, 1.0 );
	  back_light.position.set(100, 0, -100).normalize();
	  const back_light_helper = new THREE.DirectionalLightHelper( back_light );

	  top_light = new THREE.DirectionalLight(0xffffff, 1.0);
	  top_light.position.set(0, -100, 0);

	  scene.add(key_light);
	  scene.add(fill_light);
	  scene.add(back_light);
	  //scene.add(top_light);

	  // Model

	  const query_string = window.location.search;
	  const url_params = new URLSearchParams(query_string);

	  const asset = url_params.get('asset');
	  
	  const xhttp = new XMLHttpRequest();
	  
	  xhttp.open('GET', 'http://localhost:9393/assets/'+asset);
	  xhttp.setRequestHeader('Content-Type', 'application/json');
	  xhttp.setRequestHeader('Authorization', 'Metaspace-Token api_key=136:619746b7f0441005bfa7e945c05988fc');
	  
	  const loader = new STLLoader();

	  xhttp.onreadystatechange = function() {
	      if (this.readyState == 4 && this.status == 200) {
		  const asset = JSON.parse(this.response).data;
		  
		  loader.load(asset.url, function ( geometry ) {
		      const material = new THREE.MeshPhongMaterial( { color: 0x00bbee, specular: 0x111111, shininess: 100 } );
		      ASSET = new THREE.Mesh( geometry, material );

		      ASSET.position.set(0, 0, 0);
		      ASSET.translation = geometry.center();

		      // :NOTE: 20200513 Terry:
		      // Rotation for SHINING 3D Autoscan DS-EX Upper Jaw
		      
		      ASSET.rotation.set(Math.PI / 2, Math.PI, - Math.PI / 2);

		      scene.add(ASSET);
		  });
		  
	      }
	  };
	  
	  xhttp.send();

	  //scene.add(new THREE.AxesHelper(100));
	  
	  // Renderer
	  
	  renderer = new THREE.WebGLRenderer();
	  renderer.setPixelRatio(window.devicePixelRatio);
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  renderer.setClearColor( 0x2d2d2d );
	  
	  container.appendChild(renderer.domElement);

	  // Controls

	  controls = new OrbitControls(camera, renderer.domElement);
	  controls.enablePan = false;
	  controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
	  controls.dampingFactor = 0.1;
	  controls.screenSpacePanning = false;
	  controls.minDistance = 100;
	  controls.maxDistance = 500;
	  controls.maxPolarAngle = 2 * Math.PI;

	  // Raycaster
	  
	  raycaster = new THREE.Raycaster();

	  // Events

	  window.addEventListener('click', onClick, false);
	  window.addEventListener('keydown', onKeyboardEvent, false);
	  window.addEventListener('keyup', onKeyboardEvent, false);
	  window.addEventListener('mousemove', onDocumentMouseMove, false);
	  window.addEventListener('resize', onWindowResize, false);
	  
      }

      function onClick(e) {
	  if (SHIFT_IS_DOWN) {
	      raycaster.setFromCamera(MOUSE, camera);

	      const intersects = raycaster.intersectObject(ASSET);

	      if (intersects.length > 0) {
		  const geometry = new THREE.SphereGeometry( 0.5, 32, 32 );
		  const material = new THREE.MeshPhongMaterial( { color: 0xff33bb, specular: 0x111111, shininess: 100 } );
		  const sphere = new THREE.Mesh( geometry, material );
		  sphere.position.x = intersects[0].point.x;
		  sphere.position.y = intersects[0].point.y;
		  sphere.position.z = intersects[0].point.z;
		  PICKED_POINTS.add( sphere );
	      }
	  }
      }

      function onKeyboardEvent(e) {
	  SHIFT_IS_DOWN = e.shiftKey;

	  if (SHIFT_IS_DOWN) {
	      document.body.style.cursor = 'crosshair';
	  } else {
	      document.body.style.cursor = 'default';
	  }
      }
      
      function onDocumentMouseMove(e) {
	  e.preventDefault();
	  
	  MOUSE.x = ( e.clientX / window.innerWidth ) * 2 - 1;
	  MOUSE.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
      }

      function onWindowResize() {
	  aspect = window.innerWidth / window.innerHeight;

	  camera.left = -frustumSize * aspect / 2;
	  camera.rigt = frustumSize * aspect / 2;
	  camera.top = frustumSize / 2;
	  camera.bottom = -frustumSize / 2;
	  camera.updateProjectionMatrix();

	  renderer.setSize(window.innerWidth, window.innerHeight);
      }

      
      function animate() {
	  requestAnimationFrame(animate);
	  update();
	  render();
      }

      function update() {
	  controls.update();
      }
      
      function render() {
	  renderer.render(scene, camera);
      }

    </script>
  </body>
</html>
